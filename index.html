<!doctype html>
<html lang="en">
<head>
<title>A Semi-Quick Introduction To Emacs</title>
<!-- 2019-09-10 Tue 00:25 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="generator" content="Org-mode">
<meta name="author" content="Alex Birdsall">

<link  href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.5/css/bootstrap.min.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.5/js/bootstrap.min.js"></script>
<style type="text/css">
/* org mode styles on top of twbs */

html {
    position: relative;
    min-height: 100%;
}

body {
    font-size: 18px;
    margin-bottom: 105px;
}

footer {
    position: absolute;
    bottom: 0;
    width: 100%;
    height: 101px;
    background-color: #f5f5f5;
}

footer > div {
    padding: 10px;
}

footer p {
    margin: 0 0 5px;
    text-align: center;
    font-size: 16px;
}

#table-of-contents {
    margin-top: 20px;
    margin-bottom: 20px;
}

blockquote p {
    font-size: 18px;
}

pre {
    font-size: 16px;
}

.footpara {
    display: inline-block;
}

figcaption {
  font-size: 16px;
  color: #666;
  font-style: italic;
  padding-bottom: 15px;
}

/* from twbs docs */

.bs-docs-sidebar.affix {
    position: static;
}
@media (min-width: 768px) {
    .bs-docs-sidebar {
        padding-left: 20px;
    }
}

/* All levels of nav */
.bs-docs-sidebar .nav > li > a {
    display: block;
    padding: 4px 20px;
    font-size: 14px;
    font-weight: 500;
    color: #999;
}
.bs-docs-sidebar .nav > li > a:hover,
.bs-docs-sidebar .nav > li > a:focus {
    padding-left: 19px;
    color: #A1283B;
    text-decoration: none;
    background-color: transparent;
    border-left: 1px solid #A1283B;
}
.bs-docs-sidebar .nav > .active > a,
.bs-docs-sidebar .nav > .active:hover > a,
.bs-docs-sidebar .nav > .active:focus > a {
    padding-left: 18px;
    font-weight: bold;
    color: #A1283B;
    background-color: transparent;
    border-left: 2px solid #A1283B;
}

/* Nav: second level (shown on .active) */
.bs-docs-sidebar .nav .nav {
    display: none; /* Hide by default, but at >768px, show it */
    padding-bottom: 10px;
}
.bs-docs-sidebar .nav .nav > li > a {
    padding-top: 1px;
    padding-bottom: 1px;
    padding-left: 30px;
    font-size: 12px;
    font-weight: normal;
}
.bs-docs-sidebar .nav .nav > li > a:hover,
.bs-docs-sidebar .nav .nav > li > a:focus {
    padding-left: 29px;
}
.bs-docs-sidebar .nav .nav > .active > a,
.bs-docs-sidebar .nav .nav > .active:hover > a,
.bs-docs-sidebar .nav .nav > .active:focus > a {
    padding-left: 28px;
    font-weight: 500;
}

/* Nav: third level (shown on .active) */
.bs-docs-sidebar .nav .nav .nav {
    padding-bottom: 10px;
}
.bs-docs-sidebar .nav .nav .nav > li > a {
    padding-top: 1px;
    padding-bottom: 1px;
    padding-left: 40px;
    font-size: 12px;
    font-weight: normal;
}
.bs-docs-sidebar .nav .nav .nav > li > a:hover,
.bs-docs-sidebar .nav .nav .nav > li > a:focus {
    padding-left: 39px;
}
.bs-docs-sidebar .nav .nav .nav > .active > a,
.bs-docs-sidebar .nav .nav .nav > .active:hover > a,
.bs-docs-sidebar .nav .nav .nav > .active:focus > a {
    padding-left: 38px;
    font-weight: 500;
}

/* Show and affix the side nav when space allows it */
@media (min-width: 992px) {
    .bs-docs-sidebar .nav > .active > ul {
        display: block;
    }
    /* Widen the fixed sidebar */
    .bs-docs-sidebar.affix,
    .bs-docs-sidebar.affix-bottom {
        width: 213px;
    }
    .bs-docs-sidebar.affix {
        position: fixed; /* Undo the static from mobile first approach */
        top: 20px;
    }
    .bs-docs-sidebar.affix-bottom {
        position: absolute; /* Undo the static from mobile first approach */
    }
    .bs-docs-sidebar.affix .bs-docs-sidenav,.bs-docs-sidebar.affix-bottom .bs-docs-sidenav {
        margin-top: 0;
        margin-bottom: 0
    }
}
@media (min-width: 1200px) {
    /* Widen the fixed sidebar again */
    .bs-docs-sidebar.affix-bottom,
    .bs-docs-sidebar.affix {
        width: 263px;
    }
}
</style>
<script type="text/javascript">
$(function() {
    'use strict';

    $('.bs-docs-sidebar li').first().addClass('active');

    $(document.body).scrollspy({target: '.bs-docs-sidebar'});

    $('.bs-docs-sidebar').affix();
});
</script>
</head>
<body>
<div id="content" class="container">
<div class="row"><div class="col-md-9"><h1 class="title">A Semi-Quick Introduction To Emacs</h1>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> why emacs is worth the bother</h2>
<div class="outline-text-2" id="text-1">
<p>
Emacs has a few unusual properties which work together really well, making for a super powerful,
flexible system that's easier to bend to your will in sophisticated ways than almost anything
else around. That might sound a little intimidating, but most day-to-day emacs usage isn't
reinventing the world; but when you want to do something custom, the power is right at your
fingertips. Literally.
</p>

<p>
What are those properties? Well:
</p>

<ol class="org-ol">
<li>Emacs is configured with a full-fledged, high-level programming language, with functions, control
flow, etc. Emacs lisp is a dynamic functional language; the syntax is out of the ordinary, but
under the hood, it's a little like old-school javascript with an emphasis on linked lists,
strings, and text buffers. Except for macros, which are powerful like magic, only less&#x2026;
magical.
</li>

<li>Literally everything you can do in emacs, including really basic stuff like "move the cursor
forwards 15 characters" and "insert the text <code>function fo() { return "haha this was not named foo" }</code>" can be
scripted with emacs lisp. Here:
<div class="org-src-container">

<pre class="src src-emacs-lisp"><span style="color: #51afef;">(</span>forward-char <span style="color: #da8548; font-weight: bold;">15</span><span style="color: #51afef;">)</span>
<span style="color: #51afef;">(</span>insert <span style="color: #98be65;">"function fo() { return \"haha this was not named foo\" }"</span><span style="color: #51afef;">)</span>
</pre>
</div>
</li>

<li>Literally every user interaction follows the same model: you hit a key (or equivalent, like
clicking the mouse), which triggers some lisp function.
</li>

<li>You can look up, at any time you want, the name of the function bound to any key; the full
documentation for any function (with a hyperlink to its source code, so you can dig as deep as
you want); and the value of any variable. Just type <code>C-h</code> and then one of <code>k</code>, <code>f</code>, or <code>v</code> (guess which
is which). (There are lots more help options under that <code>C-h</code> prefix, too.)
</li>

<li>Literally any keystroke and combination can be bound to any function you want.
</li>
</ol>

<p>
I know I used "literally" a lot in there, but lots of programs make sweeping "[verb] any
[noun]!"-type claims that are only <i>mostly</i> true.
</p>

<p>
Anyway, once you internalize the logic of this system, you have superpowers! Did something weird
just happen? Type <code>C-h k</code>, then hit the same keystroke again to find out what function is responsible.
Want to change what that keystroke does? You can, on the fly. You always open the same file, so you
want a shortcut? That's like a 30s customization, once you're used to emacs. Want to do something
fancy, but you don't know what the right function is named? Just search all the functions that exist
by name, to see if one sounds right, then read its documentation to be sure.
</p>

<p>
Emacs has a lot of janky and/or bullshit characteristics, due to its long history and occasionally
just due to the intransigence of the neckbeards who run the project. But no emacs user is beholden
to those neckbeards: if you don't like it, you can change it. Or better yet, you can find someone
else who already changed it the way you want and put that shit on github.
</p>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> seriously, before you get started: remap caps lock to control</h2>
<div class="outline-text-2" id="text-2">
<p>
Caps lock is useless. Control is <i>constantly</i> used in emacs. As a bonus, lots of standard emacs
shortcuts for text navigation (<code>C-a</code> to jump to start of line; <code>C-e</code> to jump to end of line; <code>C-k</code> to
delete from the cursor to the end of text or the next newline, whichever comes first; <code>C-t</code> to
"transpose" two characters when you make a tyop; <code>C-n</code> and <code>C-p</code> to go down/up one line) work in the
shell and in almost all OSX text fields. If control is where caps lock was, all this is right on
home row, super easy and ergonomic to use. If not, you sort of end up making weird claw hands all
the time.
</p>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> okay, with that out of the way: quick start</h2>
<div class="outline-text-2" id="text-3">
<p>
Lots of people will tell you that stock emacs sucks. That is because stock emacs kind of sucks. We
can do better than that.
</p>
</div>
<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> Install a version of emacs that isn't awful</h3>
<div class="outline-text-3" id="text-3-1">
<p>
If you're on a mac, there is an <code>emacs</code> pre-installed, but it's like 10 years out of date and only
works in the terminal. It's good for one thing:
</p>

<div class="org-src-container">

<pre class="src src-shell"><span style="color: #5B6268;"># </span><span style="color: #5B6268;">haha, good luck figuring out how to close emacs</span>
emacs -q --no-splash -f tetris
</pre>
</div>
<p>
Tetris? Remember, you can rebind any keystroke to run your own code, and emacs will do any song and
dance you're clever/patient enough to write. Web browsers were originally just for viewing
documents, too.
</p>

<p>
For your non-tetris needs, you'll want to do one of these
</p>
<div class="org-src-container">

<pre class="src src-shell"><span style="color: #5B6268;"># </span><span style="color: #5B6268;">good, but ought to be better</span>
brew install emacs

<span style="color: #5B6268;"># </span><span style="color: #5B6268;">much better, unless connecting to your running emacs from the terminal is important to you</span>
<span style="color: #5B6268;"># </span><span style="color: #5B6268;">(and if it is, you probably don't need introductory notes?)</span>
brew tap railwaycat/emacsmacport
brew install emacs-mac
</pre>
</div>

<p>
Why is the normal emacs not the best choice for mac? Because the Free Software Foundation people are
assholes about everything but linux. Sorry, "GNU/linux". So some guy forked emacs so he could add
e.g. native OSX smooth scrolling and shit.
</p>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> Install a starter kit</h3>
<div class="outline-text-3" id="text-3-2">
<p>
These have gotten popular these days. Basically, these are community-maintained configurations on
top of emacs. They add in useful third-party libraries (in some cases, so useful they have become de
facto standards), update the styling so emacs looks like it's from the present, instead of the
mid-90s, and usually offer a bunch of variables you can tweak to easily toggle features and stuff.
They're generally intended to be a more powerful and beautiful "batteries included" starting point
for people. To install a starter kit, just clone the project repository to <code>~/.emacs.d</code>; when you next
start emacs, it will automatically load that code.
</p>
</div>
<div id="outline-container-sec-3-2-1" class="outline-4">
<h4 id="sec-3-2-1"><span class="section-number-4">3.2.1</span> If you like piña coladas, and getting stuck in a vim session</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
My favorite is Spacemacs (<a href="http://spacemacs.org/">http://spacemacs.org/</a>). It's also probably the most popular, and
therefore the best supported, with the most stack overflow answers a quick google away. Spacemacs
is written by and for people who like vim's command language (which is an insanely good fit for
emacs' keybinding model, actually), but you don't need to use it in a vimmy way. Most people do,
because it's insanely good like that, but you do you. Spacemacs has a wonderful system of mnemonic
commands that you access via a universal prefix key, which is the space bar if you use vim
keybindings and something else if you don't. I'd honestly recommend spacemacs even if you choose
not to use vim bindings at all.
</p>
</div>
</div>
<div id="outline-container-sec-3-2-2" class="outline-4">
<h4 id="sec-3-2-2"><span class="section-number-4">3.2.2</span> If you want something more traditionally emacsy, because you don't give a fuck about vim</h4>
<div class="outline-text-4" id="text-3-2-2">
<p>
A venerable starter kit that's a bit more mainline emacs is Prelude
(<a href="https://github.com/bbatsov/prelude">https://github.com/bbatsov/prelude</a>). I haven't used it, so I can't comment on it much, but I've
heard very good things, and its primary maintainer is pretty legit.
</p>
</div>
</div>
<div id="outline-container-sec-3-2-3" class="outline-4">
<h4 id="sec-3-2-3"><span class="section-number-4">3.2.3</span> If you want to be FANCY</h4>
<div class="outline-text-4" id="text-3-2-3">
<p>
A new one is Centaur (<a href="https://github.com/seagle0128/.emacs.d">https://github.com/seagle0128/.emacs.d</a>). Centaur is very pretty and into
normal modern UI stuff like file trees with icons and tabs and stuff.
</p>

<p>
Oh yeah, emacs doesn't really even have decent tab support? Centaur tabs are clever, but a hack. I
dunno, y'all, nothing's perfect.
</p>

<p>
Cool, you have a modern version of emacs, and now it looks adequate. Let's get oriented.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> A quick tour of essential emacs keybindings</h3>
<div class="outline-text-3" id="text-3-3">
<p>
You can remap any key in any mode, but the defaults are around until and unless you change them, so
they're worth knowing. I'm assuming you didn't install spacemacs in vim mode; if you did, a few
parts of this won't generally apply.
</p>

<p>
By convention, emacs documents keystrokes (in all of its documentation and when reporting what keys
a function is bound to) a certain way. I've already used it above. Here's a more complicated
keybinding:
</p>
<blockquote>
<p>
<code>C-x c</code>
</p>
</blockquote>
<p>
This means "hold control and type x; then type c". You never hit control except in combination with
other keys, so the "c" character is unambiguous in both spots there. In keybinding notation, dashes
mean "hit these two keys together" and spaces mean "after typing key X, release the keys and then
type key Y".
</p>

<p>
Two modifier keys are king in emacs: control, which is the control key, and meta, which is the alt
key. It's weird, but emacs literally predates the alt key being standard. Meta is <code>M-[something]</code> in
keybinding notation.
</p>

<p>
If you're a hipster like me, you might switch things up so that the mac command key is meta
instead of alt. Emacs is what you make it.
</p>
</div>

<div id="outline-container-sec-3-3-1" class="outline-4">
<h4 id="sec-3-3-1"><span class="section-number-4">3.3.1</span> First command to learn: <code>M-x</code> lets you run commands by name</h4>
<div class="outline-text-4" id="text-3-3-1">
<p>
A decent starter configuration will give you a nice fuzzy search interface when you hit <code>M-x</code>. Start
typing, and when the command you want comes up in the results, you can use the arrow keys and enter
to execute that command. Don't remember the keybinding for some functionality? Hit <code>M-x</code> and start
typing its name. Since keyboard space is finite, some commands can only be run like this. For
example, <code>M-x snake</code> starts a game of snake, and <code>M-x doctor</code> starts a psychotherapy session with
everyone's favorite 1960s chatbot ELIZA.
</p>
</div>
</div>

<div id="outline-container-sec-3-3-2" class="outline-4">
<h4 id="sec-3-3-2"><span class="section-number-4">3.3.2</span> First commands to learn: what to do when you panic</h4>
<div class="outline-text-4" id="text-3-3-2">
<p>
<code>C-x C-c</code> 
</p>

<p>
Within a session, if emacs freezes, or starts acting weird, or you mistype and find yourself halfway
into the wrong key sequence, start spamming <code>C-g</code> to cancel out of whatever the current thing is. The
downside to letting people run their own code is that sometimes they write dumb code and have stuff
like infinite loops. In cases like this, <code>C-g</code> is your friend. You can also spam the escape key: on
the rare occasion <code>C-g</code> doesn't work, three escapes usually will.
</p>
</div>
</div>

<div id="outline-container-sec-3-3-3" class="outline-4">
<h4 id="sec-3-3-3"><span class="section-number-4">3.3.3</span> There's a method to the madness</h4>
<div class="outline-text-4" id="text-3-3-3">
<p>
Really quick commands you will do while you type code/prose/emails/whatever are bound to control
[something] or meta [something], so you can just bust them out quickly. Commands that are common but
that you're less likely to use in quick succession, like saving, managing your windows, quitting
emacs, etc, are under the <code>C-x</code> prefix (the "x" is for "execute command": Emacs tries to make stuff
mnemonic). Commands that are less common than that (or when you remember the name but not the
keybinding), you can type <code>M-x</code> and find them by name. The similarity of the two "execute command"
keybindings, <code>C-x</code> and <code>M-x,</code> is not a coincidence. Mnemonic, remember?
</p>

<p>
That's a decent intro to the standardish sort-of-hierarchy for what different modifier keys mean
with the same key. <code>C-f</code> goes forwards one character; <code>M-f</code> goes forwards one word; <code>C-M-f</code> goes
forward one semantic unit (paired quotes or braces, a code block, or whatever: different language
modes can define what a semantic unit is, and emacs has some more-or-less sensible global defaults).
When "same thing, but with a wider scope" doesn't make sense, sometimes control and meta do opposite
versions of the same thing. I don't want to bog you down with examples, though: you can get by for a
while using arrow keys, the mouse, and a small handful of memorized commands.
</p>

<p>
The file menu is a nice way to find commands at first, too, though you'll probably leave it behind
as you internalize a more keyboard-driven workflow.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> what is a mode, even</h3>
<div class="outline-text-3" id="text-3-4">
<p>
Modes are how emacs lets you apply or remove related configurations and keybindings en masse.
Functions that manipulate ruby code only make sense if you're editing a ruby file; so those
keybindings only apply when <code>ruby-mode</code> is active. <code>ruby-mode</code> is a <i>major</i> mode.
</p>

<p>
Every buffer has one (1) major mode. This says what kind of thing that buffer is. Is it a file of
some programming language? Each programming language has its own major mode (sometimes you even have
a couple options, because open source). Is the buffer an interactive feature, like a game of tetris
or a git dashboard? Is it some elisp function's documentation? That's the major mode. You can use
<code>M-x</code> to change the major mode (they're just functions, under the hood), and interact with the buffer
contents in a different way, but you almost never have to.
</p>

<p>
You can only have one major mode per buffer, but you can have as many minor modes as you want.
Minor modes tend to wrap a few related functions and settings into some feature, so you can easily
toggle the feature by (de)activating the minor mode. Autocomplete is a minor mode. Spell-check is a
minor mode. <a href="https://elpa.gnu.org/packages/rainbow-mode.html">rainbow-mode</a> is a minor mode, and makes writing CSS so much nicer. A <a href="https://github.com/TeMPOraL/nyan-mode">nyan cat status bar</a>
to tell you how far into a buffer you are? Minor mode. Most features are implemented as minor modes.
</p>
</div>
</div>

<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5"><span class="section-number-3">3.5</span> [one of] the killer app[s]: org-mode</h3>
<div class="outline-text-3" id="text-3-5">
<p>
<code>org-mode</code> is sort of like markdown on steroids. You can rearrange the order and level of headings
interactively on the fly; edit code snippets as if they were actual files, with full language
support; edit tables like a spreadsheet; export your notes to pdf, html, LaTeX, github-flavored
markdown (although github parses <code>.org</code> files just like it does <code>.md</code> ones), or a reveal.js slideshow;
and so, so much more. I wrote this page as some quick-and-dirty notes in <code>org-mode</code> (seriously: if you
replace <code>index.html</code> with <code>index.org</code>, you can see the raw source). <code>org-mode</code> started out life as a
third-party package for emacs, but it is so good and became so popular that it's included with emacs
now.
</p>

<p>
The basics (slightly different markdown with magic table formatting and built-in todo list support!)
are simple to learn and legitimately powerful on their own; but its feature set is so deep, you can
spend years learning it and still not know everything. Even if you never use emacs for anything
else, <code>org-mode</code> is worth it.
</p>

<p>
Honest-to-god: take 30ish minutes of your life (you don't need to watch the Q and A for pete's sake)
and watch this presentation that Carsten Dominik, the German astronomer who authored org-mode, gave at
google:
</p>

<p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/oJTwQvgfgMM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</p>
</div>
</div>
</div>
</div><div class="col-md-3"><nav id="table-of-contents">
<div id="text-table-of-contents" class="bs-docs-sidebar">
<ul class="nav">
<li><a href="#sec-1">1. why emacs is worth the bother</a></li>
<li><a href="#sec-2">2. seriously, before you get started: remap caps lock to control</a></li>
<li><a href="#sec-3">3. okay, with that out of the way: quick start</a>
<ul class="nav">
<li><a href="#sec-3-1">3.1. Install a version of emacs that isn't awful</a></li>
<li><a href="#sec-3-2">3.2. Install a starter kit</a></li>
<li><a href="#sec-3-3">3.3. A quick tour of essential emacs keybindings</a></li>
<li><a href="#sec-3-4">3.4. what is a mode, even</a></li>
<li><a href="#sec-3-5">3.5. [one of] the killer app[s]: org-mode</a></li>
</ul>
</li>
</ul>
</div>
</nav>
</div></div></div>
<footer id="postamble" class="">
<div><p class="author">Author: Alex Birdsall</p>
<p class="date">Created: 2019-09-10 Tue 00:25</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 26.2 (<a href="http://orgmode.org">Org-mode</a> 9.2.5)</p>
</div>
</footer>
</body>
</html>
